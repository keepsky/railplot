-- Check that we at least have an input filename.
-- If not, print the help message and exit.
check_args(input_file ~= nil, "No input file given")

style = style or "simple"

-- Gather input
if input_format == "railml" then
    model = load_railml { 
        -- Load a railml file.
        filename = input_file,
        arrays = { "signals","trainDetectionElements","balises" },

        -- Extract objects from each track.
        track_objects = function(track)
            objs = {}
            if track.ocsElements ~= nil then
                extend(objs,track.ocsElements.signals)
                extend(objs,track.ocsElements.trainDetectionElements)
                extend(objs,track.ocsElements.balises)
            end
            return objs
        end,

        -- Use each railml element's absPos value for linear positioning.
        -- This requires the file to be direction-consistent (meaning, for example,
        -- that outgoing switches can only connect to beginnings of other tracks,
        -- and incoming switches to the ends of other tracks).
        -- And it requires the linear positions (absolute positions) 
        -- to be consistent with the directions.
        get_pos = function(o) return o.absPos or o.pos end,

        -- Get the symbol info, i.e. level, width, origin and linear position.
        symbol_info = function(o) 
            if o._elem == "signal" then
                level = o.dir == "up" and -1 or 1
                origin = o.dir == "up" and 0.0 or 0.4
                return { pos = o.absPos or o.pos, 
                width=0.4, origin = origin, level = level }
            elseif o._elem == "balise" then
                return { pos = o.absPos or o.pos, 
                width=0.15, origin = 0.15/2.0, level = 0 }
            elseif o._elem == "trainDetector" then
                return { pos = o.absPos or o.pos, 
                width=0.05, origin = 0.025, level = 0 }
            else
            log_warn("No symbol sizing support for element type " .. tostring(o._elem))
            end
        end,
    }

else
    error "Unknown input format."
end

-- Run the solver 
output = plot_network {
    model=model,
}



-- Symbols
--
function draw_symbol(o) 
    if o._elem == "signal" then
        a = "" 
        xl = -o._symbol_info.origin
        xr = xl + o._symbol_info.width
        ytop    = 0.125
        ybottom = -0.125

        --a = a.. rect(xl,ybottom,xr,ytop)

        if o.dir == "up" then
            a = a.. line(0,0.05,0,-0.05)
            a = a.. line(0,0,0.1,0)
            a = a.. circle(0.15,0,0.05)
        else 
            a = a.. line(xr-0,0.05,  xr-0,-0.05)
            a = a.. line(xr-0,0,     xr-0.1,0)
            a = a.. circle(xr-0.15,0,0.05)
        end

        return a
    elseif o._elem == "trainDetector" then
        return line(0,-0.05,0,0.05)
    elseif o._elem == "balise" then
        a = ""
        s = 0.06
        x0,y0 = 0.0*s,1.0*s
        x1,y1 = -0.866*s, -0.5*s
        x2,y2 = 0.866*s, -0.5*s
        return fillpath({{x0,y0},{x1,y1},{x2,y2}})
    else
        log_warn("No symbol support for element type " .. tostring(o._elem))
        return ""
    end
end 


-- Write output
--
if output_format == nil or output_format == "json" then
    -- JSON output is simply a dump of the output from plot_network.
    -- It consists of node coodinates, edge polylines, and symbol coordinates.
    write(output_file, to_json_pretty(output))

elseif output_format == "tikz" or output_format == "pdf" then
    -- TiKZ is a graphics package for LaTeX (see 
    -- https://en.wikibooks.org/wiki/LaTeX/PGF/TikZ).
    -- Built-in functions draw tracks and filled switches, and 
    -- translate and rotate the symbols in place. The draw argument
    -- to the tikz_symbols function is called for each symbol, and should
    -- return a string, which is placed into the TikZ output verbatim.

    function rect(x0,y0,x1,y1)
        return "\\draw ("..x0..","..y0..") rectangle ("..x1..","..y1..");"
    end
    function line(x0,y0,x1,y1)
        return "\\draw ("..x0..","..y0..") -- ("..x1..","..y1..");"
    end
    function circle(x,y,r)
        return "\\draw ("..x..","..y..") circle ("..r..");"
    end
    function fillpath(xs)
        local a = ""
        local first = true
        for i,v in ipairs(xs) do
            if first then
                first = false
            else
                a = a .. " -- "
            end
            a = a .. "(" .. v[1] .. "," .. v[2] .. ")"
        end
        return "\\path[fill=black] " .. a .. ";"
    end

    tikz = ""
    tikz = tikz .. (tikz_tracks   { data = output, style = "thick, black", title=title })
    tikz = tikz .. (tikz_switches { data = output, style = "" })
    tikz = tikz .. (tikz_symbols  { data = output, draw = draw_symbol})

    if output_format == "tikz" then 
        write(output_file, tikz)
    else 
        -- PDF output is generated by calling pdflatex on the TikZ code.
        check_args(output_file ~= nil and output_file ~= "-", 
            "Output filename required for PDF output")
        tikzpdf(output_file,tikz)
    end


elseif output_format == "svg" or output_format == "png" then
    function rect(x0,y0,x1,y1)
        return "<rect x=\"" .. x0 .. "\" y=\"" .. y0 .. "\"" ..  " width=\"" .. (y1-y0) .. "\" height=\"".. (x1-x0) .. "\" />"
    end
    function line(x0,y0,x1,y1)
        return "<line x1=\"" .. x0 .. "\" y1=\"" .. y0 .. "\" x2=\"" .. x1 .. "\" y2=\"" .. y1 .. "\" stroke=\"black\" stroke-width=\"0.02\"/>"
    end
    function circle(x,y,r)
        return "<circle cx=\"".. x .. "\" cy=\"".. y .. "\" r=\"".. r .. "\" stroke=\"black\" fill=\"none\" stroke-width=\"0.02\"/>"
    end
    function fillpath(xs)
        local a = ""
        local first = true
        for i,v in ipairs(xs) do
            if first then
                first = false
                a = a .. "M" .. v[1] .. " " .. v[2]
            else
                a = a .. "L" .. v[1] .. " " .. v[2]
            end
        end
        return "<path d=\"" .. a .. "\" fill=\"black\" stroke=\"none\" />"
    end

    function box_draw(o) 
        xl = -o._symbol_info.origin
        xr = xl + o._symbol_info.width
        ytop    = 0.125
        ybottom = -0.125
        return "<rect x=\"" .. tostring(xl) .. "\" width=\"" .. tostring(xr-xl) .. "\" y=\"" .. tostring(ybottom) .. "\" height=\"" .. tostring(ytop-ybottom) .. "\" />"
    end 

    scale = 100.0
    size = drawing_size { data = output }
    svg = ""
    svg = svg .. (svg_tracks   { data = output, scale=scale, size=size, title = title ,
        style="fill=\"none\" stroke=\"black\" stroke-width=\"3\"" })
    svg = svg .. (svg_switches { data = output, scale=scale, size=size,
        style="fill=\"black\"" })
    svg = svg .. (svg_symbols  { data = output, scale=scale, size=size,
        draw = draw_symbol})
    svg = svg_document { contents = svg, scale = scale, size = size}

    if output_format == "svg" then
        write(output_file, svg)
    else
        check_args(output_file ~= nil and output_file ~= "-")
        rsvgpng(output_file,svg, {background_color="white"})
    end

else
    error "Unknown output format."
end


